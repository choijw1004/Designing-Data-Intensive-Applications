## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운애플리케이션 

오늘날 많은 애플리케이션은 계산 중심과는 다르게 데이터 중심적이다. 데이터 중심 어플리케이션의 경우에는 일반적으로 다음 다섯가지를 필요로한다.

1. 각기 다른 어플리케이션에서 데이터베이스를 찾을 수 있게 데이터베이스를 저장 (데이터베이스)
2. 읽기 속도 향상을 위해 값비싼 수행 결과를 기억(캐시)
3. 사용자가 키워드로 데이터를 검색할 수 있게 제공(검색 색인(index))
4. 비동기 처리를 위해 다른 프로세스로 메시지 보내기(스트림 처리)
5. 주기적으로 대량의 누적된 데이터를 분석(일괄처리(batch))

따라서 이러한 조건을 갖춘 시스템을 잘 설계하는 것이 현대 어플리케이션의 주요 목적이자 목표이다. 

이러한 현대 어플리케이션 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사는 다음과 같다.

1. 신뢰성(Reliability)
2. 확장성(Scalability)
3. 유지보수성(Maintainability)

## 신뢰성(Reliability)
소프트웨어 시스템에서 **올바르게** 동작한다는 것은 **무언가 잘못되더라도 지속적으로 올바르게** 동작한다는 것으로 이해할 수 있다. 여기서 잘못될 수도 있는 일은 결함(fault)라고 부르고 이러한 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault - tolerant) 또는 탄력성을 지녔다고 말한다. 결함과 장애는 자칫 같은 뜻이라고 해석할 수도 있지만 본질적으로 동일하지 않다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의 되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘경우이다.

다음은 결함의 세 가지 종류이다.

### 1. 하드웨어 결함
말 그대로 하드웨어 결함이다. 하드디스크가 고장 나고, 램에 결함이 생기고, 대규모 정전 사태가 발생하고, 누군가가 네트워크 케이블을 잘못 뽑는 결함을 말한다. 일반적으로 이러한 하드웨어 결함을 예방하기 위해서 디스크 단위에서는 RAID로, 서버에서는 핫 스왑이 가능한 CPU를 도입하는 것 처럼 말이다.

### 2. 소프트웨어 오류
보통 하드웨어 결함을 무작위적이고 서로 독립적이라고 이야기하지만 소프트웨어 오류는 그렇지 않다. 그렇기에 이런 문제는 신속한 해결책이 없어 시스템의 가정과 상호작용에 따라서 빈틈없는 테스트, 프로세스 격리, 등과 같은 사후 처리의 용도로 경고를 발생시켜 해결해야한다.

### 3. 인적 오류
사람은 소프트웨어 시스템을 설계하고 구축하며, 운영자로서 시스템을 계속 운영한다. 그렇기에 인적오류는 반드시 발생할 것이고 이를 예방하기 위해 테스트 도구의 활용, 성능 지표와 명확한 모니터링, 쉬운 복구와 같은 방법으로 이를 예방해야만한다.

## 확장성(Scalability)
시스템이 현재 안정적으로 동작한다고 해서 미래에도 그렇다는 보장은 없다. 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가다. 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 용어다. 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?" 같은 질문을 고려한다는 의미다.

### 부하 기술하기
먼저 시스템의 현재 부하를 간결하게 기술할 수 있어야 한다. 그래야만 "부하가 두 배로 되면 어떻게 될까?" 같은 질문을 논의할 수 있다. 부하는 부하 매개변수(load parameter)라 부르는 몇 개의 숫자로 나타낼 수 있다. 적합한 부하 매개변수의 선택은 시스템 설계에 따라 달라진다. 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 동시 활성 사용자 수, 캐시 적중률 등이 부하 매개변수가 될 수 있다.

### 성능 기술하기
부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다. 이는 두 가지 방법으로 살펴볼 수 있다.

1. 부하 매개변수를 증가시키고 시스템 자원은 유지하면 성능은 어떻게 영향을 받는가?
2. 부하 매개변수를 증가시켰을 때 성능을 유지하려면 자원을 얼마나 늘려야 하는가?

일괄 처리 시스템은 처리량(throughput)에 관심을 갖고, 온라인 시스템은 응답 시간(response time)이 더 중요하다. 응답 시간을 측정할 때는 평균보다 백분위(percentile)를 사용하는 것이 좋다. 중앙값(p50)은 사용자가 보통 얼마나 기다리는지 알려주고, 상위 백분위(p95, p99, p999)는 특이 값이 얼마나 나쁜지 보여준다.

### 부하 대응 접근 방식
용량 확장(scaling up, 수직 확장)과 규모 확장(scaling out, 수평 확장)으로 구분한다. 다수의 장비로 부하를 분산하는 아키텍처를 비공유(shared-nothing) 아키텍처라고 부른다.
일부 시스템은 탄력적(elastic)이어서 부하 증가를 감지하면 자동으로 자원을 추가한다. 탄력적 시스템은 부하 예측이 어려울 때 유용하지만, 수동 확장이 더 간단하고 운영상 예상치 못한 일이 적다. 따라서 범용적이고 모든 상황에 맞는 확장 아키텍처는 없다. 읽기/쓰기 양, 저장할 데이터 양, 응답 시간 요구사항, 접근 패턴 등에 따라 적합한 아키텍처가 달라진다.

## 유지보수성(Maintainability)
소프트웨어 비용의 대부분은 초기 개발이 아니라 지속적인 유지보수에 들어간다. 버그 수정, 시스템 운영, 장애 조사, 새로운 기능 추가, 기술 부채 상환 등이 유지보수에 포함된다. 유지보수의 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않으려면 세 가지 설계 원칙에 주의해야 한다.
### 1. 운용성(Operability): 운영의 편리함 만들기
좋은 운영팀은 시스템 모니터링, 장애 원인 추적, 보안 패치 적용, 용량 계획, 배포 관리 등을 책임진다. 좋은 운용성이란 반복되는 태스크를 쉽게 수행하게 만들어 운영팀이 고부가가치 활동에 집중할 수 있게 하는 것이다.
이를 위해 데이터 시스템은 다음을 제공해야 한다.

- 런타임 동작과 시스템 내부에 대한 가시성(모니터링)
- 자동화와 통합을 위한 표준 도구 지원
- 개별 장비 의존성 회피
- 좋은 문서와 이해하기 쉬운 운영 모델
- 적절한 기본 동작과 관리자의 재정의 자유
- 자기 회복(self-healing)과 수동 제어의 균형

### 2. 단순성(Simplicity): 복잡도 관리
복잡도의 원인은 다양하다. 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 네이밍, 임시방편 해결책 등이 있다. 복잡도는 개발 속도를 늦추고 유지보수 비용을 증가시키며 버그 위험을 높인다. 단순성이 구축하려는 시스템의 핵심 목표여야 한다. 이는 기능을 줄인다는 의미가 아니라 우발적 복잡도(accidental complexity)를 줄인다는 의미다. 우발적 복잡도는 문제 자체에는 없지만 구현에서만 발생하는 복잡도다.

우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 세부 구현을 숨기고 재사용을 가능하게 한다.

### 3. 발전성(Evolvability): 변화를 쉽게 만들기
시스템 요구사항이 영원히 바뀌지 않을 가능성은 매우 적다. 새로운 사용 사례, 비즈니스 우선순위 변경, 새로운 기능 요청, 플랫폼 교체, 법적 규제 변경, 시스템 성장에 따른 아키텍처 변경 등이 발생할 수 있다.

애자일(agile) 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 테스트 주도 개발(TDD)과 리팩터링 같은 기법도 자주 변화하는 환경에서 유용하다. 데이터 시스템 수준에서 이러한 민첩성을 발전성(evolvability)이라 부른다. 단순성과 추상화가 잘 갖춰진 시스템은 변경하기도 쉽다.