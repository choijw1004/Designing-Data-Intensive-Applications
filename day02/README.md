## 데이터 모델과 질의 언어

데이터 모델은 소프트웨어 개발에서 가장 중요하다. 해결해야하는 문제를 어떻게 생각해야 하는지에 대해서도 영항을 미치기 때문이다.

### 관계형 모델과 문서 모델

오늘날 가장 잘 알려진 데이터 모델은 1970년 에드가 코드가 제안한 관계형 모델을 기반으로 한 SQL이다. 데이터는 테이블이라고 불리는 관계로 구성되고 각 관계는 순서 없는 튜플 즉, 행(row)의 모임이다.

관계형 데이터베이스의 근원은 1960 ~ 70년대에 메인 프레임 컴퓨터에서 수행된 비즈니스 데이터 처리에 있다. 이는 트랜잭션 처리와 일괄 처리로 오늘날의 관점에서 일상적으로 수행되는 일이다.

이후 네트워크 모델과 계층 모델이 주요 대안이었지만 결국 관계형 모델이 우위를 차지했고 대부분(약 80%)의 서비스는 관게형 데이터 베이스를 통해 제공되었다.

### NoSQL
NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신의 시도이다. NoSQL 데이터베이스를 채택한 데는 다음과 같은 원인이 있다.

1. 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형데이터베이스보다 쉽게 할 수 있는 확장성의 필요성
2. 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
3. rdb에서 지원하지 않는 특수 질의
4. rdb의 제약으로 인한 더욱 동적이고 풍부한 데이터 모델의 필요성

### 객체 관계형 불일치
오늘날 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발되는데 이는 코드와 데이터베이스 모델 객체 사이에 전환할 수 있는 전환 계층이 필요하다. 

이런 모델 사이의 분리를 임피던스 불일치 라고 부른다. 하이버네이트와 같은 객체 관계형 매핑 프레임워크는 이 불일치를 어느정도 해소해주지만 두 모델 간의 차이를 완전히 숨길 수 없다는 명확한 한계가 존재한다.

### 다대일과 다대다 관계
데이터 모델링에서 엔티티 간의 관계를 표현하는 방식은 크게 다대일과 다대다로 나눌 수 있다.

#### 다대일 (N:1)
다대일 관계는 여러 레코드가 하나의 레코드를 참조하는 형태다. 예를 들어 여러 주문이 하나의 회원에게 속하거나, 여러 직원이 하나의 부서에 소속되는 경우가 이에 해당한다.

관계형 모델에서 다대일 관계는 외래키를 통해 자연스럽게 표현된다. "다" 쪽 테이블에 외래키를 두어 "일" 쪽을 참조하면 된다. 이 방식은 정규화와도 밀접한 관련이 있는데, 중복 데이터를 별도 테이블로 분리하고 ID로 참조하면 데이터 일관성을 유지하면서 저장 공간도 절약할 수 있다.

반면 문서 모델에서는 다대일 관계가 자연스럽지 않다. 조인이 필요 없도록 비정규화된 문서 구조를 선호하기 때문에, 참조가 필요한 경우 애플리케이션 코드에서 직접 여러 번의 질의를 수행해야 하는 경우가 많다.

#### 다대다 (N:M)
다대다 관계는 양쪽 모두 여러 레코드와 연결될 수 있는 형태다. 학생과 강의, 게시글과 태그, 사용자와 그룹 등이 대표적인 예시다.

관계형 모델에서 다대다 관계는 중간 테이블(조인 테이블)을 통해 두 개의 다대일 관계로 풀어서 표현한다. 이 방식은 관계의 추가와 삭제가 용이하고, 중간 테이블에 관계 자체의 속성(예: 수강 신청일, 성적)을 저장할 수도 있다.
문서 모델에서 다대다 관계를 표현하려면 한쪽에 참조 ID 배열을 저장하는 방식을 사용한다. 그러나 이 경우 역방향 조회가 비효율적이고, 참조 무결성을 데이터베이스가 보장하지 않으므로 애플리케이션에서 관리해야 한다.

#### 관계 처리 방식의 차이

관계형 모델이 오랜 기간 우위를 점한 이유 중 하나는 조인 연산을 통해 다대일, 다대다 관계를 효율적으로 처리할 수 있다는 점이다. 문서 데이터베이스는 일대다 관계가 주를 이루는 경우에 적합하며, 상호 연결이 많은 데이터에는 그래프 모델이 더 자연스러운 선택이 될 수 있다.

결국 어떤 데이터 모델을 선택할지는 애플리케이션에서 가장 빈번하게 발생하는 관계 유형이 무엇인지에 따라 달라진다.

### 데이터를 위한 질의 언어

데이터 모델을 선택했다면, 그 데이터를 읽고 쓰는 방법이 필요하다. 이를 위한 질의 언어는 크게 선언형과 명령형으로 나눌 수 있다.

#### 선언형 질의

선언형 질의 언어는 **무엇**을 원하는지만 명시한다. 어떻게 가져올지는 데이터베이스가 알아서 결정한다. SQL이 대표적이다.

```sql
SELECT * FROM users WHERE age > 20 ORDER BY name;
```

이 쿼리는 "20살 넘는 사용자를 이름순으로 달라"고만 말한다. 어떤 인덱스를 쓸지, 어떤 순서로 스캔할지는 데이터베이스 옵티마이저가 판단한다. 덕분에 데이터베이스는 내부 구현을 자유롭게 개선할 수 있고, 같은 쿼리라도 상황에 따라 최적의 실행 계획을 선택할 수 있다.

#### 명령형 질의

명령형 방식은 **어떻게** 데이터를 처리할지 단계별로 직접 작성한다. 일반적인 프로그래밍 언어로 데이터를 다루는 방식이 이에 해당한다.

```javascript
const result = [];
for (const user of users) {
    if (user.age > 20) {
        result.push(user);
    }
}
result.sort((a, b) => a.name.localeCompare(b.name));
```

이 방식은 유연하지만, 최적화를 시스템에 맡기기 어렵다. 코드가 특정 실행 순서를 강제하기 때문이다.

#### MapReduce

MapReduce는 명령형과 선언형의 중간 지점에 있다. 처리 로직(Map, Reduce 함수)은 직접 작성하지만, 분산 실행과 병렬화는 프레임워크가 담당한다.

```javascript
// Map: 각 문서를 (key, value) 쌍으로 변환
map: function() {
    emit(this.category, 1);
}

// Reduce: 같은 key의 값들을 집계
reduce: function(key, values) {
    return Array.sum(values);
}
```

MongoDB는 초기에 이 방식을 지원했지만, 이후 집계 파이프라인(Aggregation Pipeline)이라는 선언형 방식으로 대체되었다. 선언형 질의가 가진 최적화 이점이 그만큼 크기 때문이다.

#### 어떤 방식을 선택하는게 좋을까?

선언형 질의는 간결하고 최적화에 유리하지만, 표현할 수 있는 연산이 제한적이다. 명령형 방식은 유연하지만 최적화와 병렬화가 어렵다. 대부분의 경우 선언형 질의로 충분하며, 복잡한 분석이나 대규모 배치 처리가 필요할 때 MapReduce나 그 후속 기술(Spark 등)을 고려하게 된다.